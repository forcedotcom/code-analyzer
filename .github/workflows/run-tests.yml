name: run-tests
on:
  workflow_call:
    inputs:
      node-matrix:
        description: "An array of node versions against which the tests should be run"
        required: false
        type: string
        default: "['lts/*']"

jobs:
  # Step 1: We have a number of dependencies that we can build now and cache
  #         for future use, to save time later.
  build-dependencies:
    runs-on: ubuntu-latest
    steps:
      # First thing's first; we need to get the code.
      - uses: actions/checkout@v2
      # Next, we need to make sure we're using the right versions of Node and Java.
      - uses: actions/setup-node@v2
        with:
          node-version: 'lts/*' # Always use Node LTS for building dependencies.
      - uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '8' # Always use Java v1.8 for building dependencies.
      # Install/build dependencies.
      - run: yarn
      - run: yarn build
      # Create a tarball.
      - run: npm pack
      # Upload the `dist` directory as an artifact so the unit test jobs have it.
      - uses: actions/upload-artifact@v3
        with:
          name: unit-test-dist
          path: ./dist
      # Upload the tarball as an artifact so the smoke test jobs have it.
      - uses: actions/upload-artifact@v3
        with:
          name: smoke-test-tarball
          path: ./salesforce-sfdx-scanner-*.tgz
  # Step 2: Run our tests.
  # Step 2A: Run the unit tests.
#  unit-tests:
#    strategy:
#      # By default, if any job in a matrix fails, all other jobs are immediately canceled. This makes the jobs run
#      # to completion instead.
#      fail-fast: false
#      matrix:
#        node: ${{ fromJson(inputs.node-matrix) }}
#        os: [ubuntu-latest, windows-2019]
#    runs-on: ${{ matrix.os }}
#    needs: build-dependencies
#    steps:
#      # Check out the code.
#      - uses: actions/checkout@v2
#      # Make sure we're using the right versions of Node and Java.
#      - uses: actions/setup-node@v2
#        with:
#          node-version: ${{ matrix.node }} # Node version is a matrix.
#      - uses: actions/setup-java@v3
#        with:
#          distribution: 'temurin'
#          java-version: '11' # For now, Java version is hardcoded. It could be changed to a matrix in the future.
#      # Install Node dependencies.
#      # NOTE: We're choosing not to cache Node dependencies, because it seems to be more
#      #       trouble than it's worth. If we see serious performance problems, we can
#      #       reconsider that assessment.
#      - run: yarn
#      # Download the dist artifact, to save ourselves the trouble of rebuilding our
#      # Java dependencies from scratch.
#      - uses: actions/download-artifact@v3
#        with:
#          name: unit-test-dist
#          path: ./dist
#      # Run the unit tests. Use the -quiet variant so SFGE logs don't blow up the console.
#      - name: Run Tests
#        run: yarn test-quiet --reporter mocha-junit-reporter --reporter-option mochaFile=test-results/mocha/test-results.xml
#      # Run the linter
#      - run: yarn lint --format junit --output-file test-results/eslint/eslint.xml
#      # Upload the test results and coverage information as artifacts.
#      - name: Upload node test artifacts
#        if: ${{ always() }}
#        uses: actions/upload-artifact@v3
#        with:
#          name: ${{ runner.os }}-node-results
#          path: |
#            ./test-results
#            ./test-coverage
#      - name: Upload pmd-cataloger test artifacts
#        if: ${{ always() }}
#        uses: actions/upload-artifact@v3
#        with:
#          name: ${{ runner.os }}-pmd-cataloger-results
#          path: |
#            pmd-cataloger/build/reports
#            pmd-cataloger/build/test-results
#      - name: Upload sfge test artifacts
#        if: ${{ always() }}
#        uses: actions/upload-artifact@v3
#        with:
#          name: ${{ runner.os }}-sfge-results
#          path: |
#            sfge/build/reports
#            sfge/build/test-results
#      - name: Upload cli-messaging test artifacts
#        if: ${{ always() }}
#        uses: actions/upload-artifact@v3
#        with:
#          name: ${{ runner.os }}-cli-messaging-results
#          path: |
#            cli-messaging/build/reports
#            cli-messaging/build/test-results
  # Step 2B: Run the smoke tests
  smoke-tests:
    strategy:
      # By default, if any job in a matrix fails, all other jobs are immediately canceled. This makes the jobs run
      # to completion instead.
      fail-fast: false
      matrix:
        node: ${{ fromJson(inputs.node-matrix) }}
        os: [{vm: ubuntu-latest, exe: .sh}, {vm: windows-2019, exe: .cmd}]
    runs-on: ${{ matrix.os.vm }}
    needs: build-dependencies
    steps:
      # Check out the code.
      - uses: actions/checkout@v2
      # Make sure we're using the right versions of Node and Java.
      - uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }} # Node version is a matrix.
      - uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '11' # For now, Java version is hardcoded. It could be changed to a matrix in the future.
      # Install Salesforce CLI via NPM
      - run: npm install -g sfdx-cli
      # Download and install the tarball artifact built during setup.
      - uses: actions/download-artifact@v3
        with:
          name: smoke-test-tarball
      - name: Install Tarball
        shell: bash
        run: |
          # We need to determine the name of the tarball
          TARBALL_NAME=$(ls | grep salesforce-sfdx-scanner-[0-9]*\\.[0-9]*\\.[0-9]*\\.tgz)
          # We also need to determine where we are.
          CURRENT_DIR=$(pwd
          # Pipe in a `y` to simulate agreeing to install an unsigned package. Use a URI of the file's full path.
          echo y | sfdx plugins:install "file://${CURRENT_DIR}/${TARBALL_NAME}"
      - run: sfdx scanner:rule:list
