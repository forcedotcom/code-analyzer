# Javascript Node CircleCI configuration file
#
# Check https://circleci.com/docs/2.0/language-javascript/ for more details
#
version: 2.1
defaults: &defaults
  working_directory: ~/repo
  docker:
    - image: circleci/openjdk:11.0.2-jdk-node

orbs:
  win: circleci/windows@2.2.0 # The Windows orb give you everything you need to start using the Windows executor.
  gradle: circleci/gradle@2.2.0
  node: circleci/node@4.5.1


commands:
  # Purpose: Checkout the code from github
  auth_and_checkout:
    steps:
      - add_ssh_keys:
          fingerprints:
            # CircleCI deploy key, allows CircleCI to checkout code from Github.
            - "63:74:04:09:64:97:7e:c6:9b:45:c0:5e:d3:7e:40:ed"
      - checkout

  # Purpose: Update node. Currently only upgrades to LTS, but could be trivially parameterized to support other versions.
  update_node:
    parameters:
      os:
        default: linux
        description: The OS being tested against
        enum:
          - linux
          - windows
        type: enum
    steps:
      # For Linux, we can just use the node orb.
      - when:
          condition:
            equal:
              - linux
              - << parameters.os >>
          steps:
            - node/install:
                install-npm: false
                # Currently, we just want to use LTS. If we want to use other versions, we can parameterize this input.
                lts: true
      # For Windows, we need to use a custom bash script.
      - when:
          condition:
            equal:
              - windows
              - << parameters.os >>
          steps:
            - run:
                name: "Install node"
                # This script must explicitly be run in bash.
                shell: bash.exe
                # Currently, we just want to use LTS. If we want to use other versions, we can parameterize this input.
                command: .circleci/windows-node-upgrade.sh lts

            # After upgrading the node version in a Windows executor, we have to manually reinstall Yarn if we want to use it.
            - run:
                name: "Install Yarn"
                shell: bash.exe
                command: npm install -g yarn
      # Regardless of OS, we want to log the version of Node we're using post-upgrade.
      - run: node -v

  # Purpose: Performs all of the follow-up actions after unit tests are executed. E.g., storing results and artifacts.
  process_unit_test_results:
    steps:
      # Store test results and artifacts
      - gradle/collect_test_results:
          reports_path: pmd-cataloger/build/reports/
          test_results_path: pmd-cataloger/build/test-results/
      - store_test_results:
          path: test-results
      - store_artifacts: # upload test coverage as artifact.
          path: test-coverage

jobs:
  setup:
    <<: *defaults
    steps:
      - auth_and_checkout

      # We'll want to use the LTS version of node.
      - update_node:
          os: linux

      # We want our unit tests to run with the lts version of node.
      - node/install:
          install-npm: false
          lts: true

      # Log the version of node we're using after the upgrade.
      - run: node -v

      # Download and cache dependencies
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "package.json" }}
            # fallback to using the latest cache if no exact match is found
            - v1-dependencies-

      # Do the necessary build steps for running unit tests
      - run: yarn --ignore-scripts
      - run: yarn build

      # Do the necessary build steps for running tarball tests
      - run: npm pack

      - save_cache:
          paths:
            - node_modules
          key: v1-dependencies-{{ checksum "package.json" }}

      - persist_to_workspace:
          root: ~/repo
          paths: .

  linux-unit-tests:
    <<: *defaults
    steps:
      - attach_workspace:
          at: ~/repo

      # We'll want to use the LTS version of node.
      - update_node:
          os: linux

      # Unit tests
      - run:
          name: test
          command: yarn test --reporter mocha-junit-reporter --reporter-option mochaFile=test-results/mocha/test-results.xml
          when: always

      # Linting
      - run:
          name: eslint
          command: yarn lint --format junit --output-file test-results/eslint/eslint.xml
          when: always

      - process_unit_test_results

  windows-unit-tests:
    executor:
      name: win/default # executor type
      size: "medium"
      shell: bash.exe
    working_directory: C:\repo
    steps:
      - attach_workspace:
          at: C:\repo

      # We'll want to use the LTS version of node.
      - update_node:
          os: windows

      - run: mkdir test-results

      # Unit tests
      - run:
          name: test
          # Necessary to explicitly use bash, otherwise gradlew's status code won't be received and the job will hang.
          shell: bash.exe
          command: yarn test --reporter mocha-junit-reporter --reporter-option mochaFile=test-results/mocha/test-results.xml
          when: always

      # Linting
      - run:
          name: eslint
          command: yarn lint --format junit --output-file test-results/eslint/eslint.xml
          shell: bash.exe
          when: always

      - process_unit_test_results

  self-evaluation:
    <<: *defaults
    steps:
      - attach_workspace:
          at: ~/repo

      - run: mkdir test-results

      - run:
          name: "list rules"
          command: bin/run scanner:rule:list

      - run:
          name: "self-evaluate"
          command: |
            bin/run scanner:run --target ./src --format junit --outfile ./test-results/src.xml --violations-cause-error
          # TODO: We'll also need to make it scan the pmd-cataloger folder once we have an easy way of making it target Java.
          # bin/run scanner:run --target ./pmd-cataloger --format junit --outfile ./test-results/pmd-cataloger.xml --violations-cause-error

      - store_test_results:
          path: test-results

      - store_artifacts:
          path: test-results


  linux-tarball-test:
    <<: *defaults
    steps:
      - attach_workspace:
          at: ~/repo

      # We'll want to use the LTS version of node
      - update_node:
          os: linux

      # Set up the plugin
      - run:
          name: "Install SFDX and tarball"
          command: |
            npm install -g sfdx-cli
            # We need to determine the name of the tarball
            SFDC_TARBALL=$(ls | grep salesforce*.tgz)
            # Pipe in a 'y' to simulate agreeing to install an unsigned plugin. Use a URI of the file's full path.
            echo y | sfdx plugins:install file://`pwd`/${SFDC_TARBALL}

      # Run through the smoke test script. If everything passes, we can assume that the plugin is stable.
      - run:
          name: "smoke test"
          command: smoke-tests/smoke-test.sh sfdx

      # Since the results are expected to be non-null, upload them as an artifact to avoid tanking the tests.
      - store_artifacts:
          path: smoke-test-results

  windows-tarball-test:
    executor:
      name: win/default # executor type
      size: "medium"
    working_directory: C:\repo
    steps:
      # Commands are run in a Windows VM environment
      - attach_workspace:
          at: C:\repo

      # Update node to LTS
      - update_node:
          os: windows

      # Set up the plugin
      - run:
          name: "Install SFDX and tarball"
          shell: bash.exe
          command: |
            npm install -g sfdx-cli
            # We need to determine the name of the tarball
            SFDC_TARBALL=$(ls | grep salesforce*.tgz)
            # Pipe in a 'y' to simulate agreeing to install an unsigned plugin.
            # Use a URI of the file's full path, but note that the path DOES NOT start with `C:`.
            echo y | sfdx plugins:install file:///repo/${SFDC_TARBALL}

      # Run through the smoke test script. If everything passes, we can assume that the plugin is stable.
      - run:
          name: "smoke test"
          command: smoke-tests\smoke-test.cmd sfdx

      # Since the results are expected to be non-null, upload them as an artifact to avoid tanking the tests.
      - store_artifacts:
          path: smoke-test-results

  linux-rc-test:
    <<: *defaults
    steps:
      - auth_and_checkout

      # We want our unit tests to run with the lts version of node.
      - update_node:
          os: linux

      - run:
          name: "Install sfdx-cli"
          command: npm install -g sfdx-cli

      - run:
          name: "Install release candidate"
          command: sfdx plugins:install --force @salesforce/sfdx-scanner@latest-rc

      - run:
          # Run through our sanity test script against the installed version of the plugin. If all of these pass, we can
          # assume that the plugin is stable.
          name: "Packaged sanity test"
          command: smoke-tests/smoke-test.sh sfdx

      # Upload an artifact for the results, so they're visible without failing the tests
      - store_artifacts:
          path: smoke-test-results

  windows-rc-test:
    executor:
      name: win/default # executor type
      size: "medium"

    steps:
      - auth_and_checkout

      # We want to run against the LTS version of node
      - update_node:
          os: windows

      - run:
          name: "Install sfdx cli"
          shell: cmd.exe
          command: npm install -g sfdx-cli

      - run:
          name: "Install release candidate"
          shell: cmd.exe
          command: sfdx plugins:install --force @salesforce/sfdx-scanner@latest-rc

      - run:
          # Run through our sanity test script against the installed version of the plugin. If all of these pass, we can
          # assume that the plugin is stable.
          name: "Packaged sanity test"
          command: smoke-tests\smoke-test.cmd sfdx

      # Upload an artifact for the results, so they're visible without failing the tests
      - store_artifacts:
          path: smoke-test-results

  publish-release-candidate:
    <<: *defaults
    steps:
      - attach_workspace:
          at: ~/repo

      - run:
          name: Verify branch of origin
          command: |
            if [ -z "$CIRCLE_TAG" ]
            then
               # If we're not actually working from a tag, then just exit. We only want to deploy tags.
               exit 1
            fi
            # For these two exports, the git command is logging out every local and remote branch that contains the tag.
            # That gets piped into a grep command so we can look for specific branches in the results.
            export CONTAINED_IN_RELEASE=$(git branch -a --contains tags/$CIRCLE_TAG|grep release)
            export CONTAINED_IN_MASTER=$(git branch -a --contains tags/$CIRCLE_TAG|grep master)
            # Our typical flow is feature branch -> dev -> release -> master. We want to publish tags based on release.
            # So we'll abort if the tag isn't present in release, or if it's present in master.
            if [ -z "$CONTAINED_IN_RELEASE" ] || [ -n "$CONTAINED_IN_MASTER" ]
            then
               exit 1
            fi

      - run: echo "Publishing would occur here. But it is disabled for now."

workflows:
  version: 2.1
  test:
    jobs:
      # First, we need to do the setup step, which sets up an environment we can use for the tests.
      # Branches are inclusive by default, and tags are exclusive by default. We want to run on all branches and no tags,
      # so no explicit filtering is required.
      - setup
      # Then we want to do the tests. Windows and Linux each have unit tests and a tarball test, and also we run the plugin
      # against itself on Linux.
      - linux-unit-tests:
          requires:
            - setup
      - windows-unit-tests:
          requires:
            - setup
      - linux-tarball-test:
          requires:
            - setup
      - windows-tarball-test:
          requires:
            - setup
      - self-evaluation:
          requires:
            - setup
  publish:
    jobs:
      # First, we need to run the setup step, which sets up an environment we can use for publishing.
      - setup:
          filters: &publishing_filters # Set an anchor so we don't have to keep declaring this.
            # We never want to publish branches, so we have to explicitly ignore them.
            branches:
              ignore: /.*/
            # We want to publish any tags that are formatted vXXXX, since that's our semantic versioning syntax.
            tags:
              only:
                /^v.*/
      # Once the setup is done, we can actually attempt the publish.
      - publish-release-candidate:
          requires:
            - setup
          filters:
            <<: *publishing_filters
      # Once the release candidate is published, we want to run our smoke tests against it.
      - linux-rc-test:
          requires:
            - publish-release-candidate
          filters:
            <<: *publishing_filters
      - windows-rc-test:
          requires:
            - publish-release-candidate
          filters:
            <<: *publishing_filters
